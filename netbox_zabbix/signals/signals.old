# singals.py
#
# Description: Handle signals
#
# init, save, delete, m2m_change, mirgate
#



from django.db.models.signals import pre_delete, post_delete, pre_save, post_save
from django.dispatch import receiver
from dcim.models import Device
from ipam.models import IPAddress
from netbox.context import current_request

from netbox_zabbix.models import  (
    DeviceAgentInterface, 
    DeviceSNMPv3Interface, 
    DeviceZabbixConfig, 
    MainChoices
)

from netbox_zabbix.models import Config
from netbox_zabbix.jobs import ImportZabbixSystemJob
from django.db import transaction

from core.models import ObjectChange

from netbox_zabbix.jobs import (
    DeleteZabbixHost,
    DeviceUpdateZabbixHost
)

import logging

logger = logging.getLogger('netbox.plugins.netbox_zabbix')

# ------------------------------------------------------------------------------
# System Jobs
# ------------------------------------------------------------------------------


@receiver(pre_save, sender=Config)
def update_system_job_schedule(sender, instance, **kwargs):
    """
    Reschedule background job.
    Only reschedule if the sync interval has changed.
    """

    if not instance.pk:
        return
    
    logger.info( "running update_system_job_schedule" )
    
    prev_config = sender.objects.get( pk=instance.pk )
    if prev_config.zabbix_sync_interval != instance.zabbix_sync_interval:
        transaction.on_commit(lambda: ImportZabbixSystemJob.schedule(instance.zabbix_sync_interval))


# ------------------------------------------------------------------------------
# Device Singals
# ------------------------------------------------------------------------------


#
# Promote Device Agent Interface
#
@receiver(post_delete, sender=DeviceAgentInterface)
def dev_promote_agent_interface_to_main(sender, instance, **kwargs):
    """
    Ensure a device always has a designated main agent interface.
    
    This signal handler is triggered after a `DeviceAgentInterface` instance 
    is deleted. If the deleted interface was marked as the main interface, 
    another available agent interface on the same host will be promoted to 
    become the new main interface.
    
    Behavior:
        - If the deleted interface was NOT the main interface, nothing happens.
        - If it was the main interface:
            - The first remaining agent interface for the host is selected.
            - That interface is promoted to `MainChoices.YES`.
            - A log entry is created documenting the promotion.
    """
    
    if instance.main == MainChoices.YES:
        logger.info( "running dev_promote_agent_interface_to_main" )
        remaining = instance.host.agent_interfaces.exclude( pk=instance.pk )
        fallback = remaining.first()
        if fallback:
            fallback.main = MainChoices.YES
            fallback.save()
            logger.info( f"Promoted interface {fallback.name} to main interface for {fallback.host.get_name()}" )



#
# Promote Device SNMPv3 Interface
#
@receiver(post_delete, sender=DeviceSNMPv3Interface)
def dev_promote_snmpv3_interface_to_main(sender, instance, **kwargs):
    """
    Ensure a device always has a designated main snmpv3 interface.
    
    This signal handler is triggered after a `DeviceSNMPv3Interface` instance 
    is deleted. If the deleted interface was marked as the main interface, 
    another available snmpv3 interface on the same host will be promoted to 
    become the new main interface.
    
    Behavior:
        - If the deleted interface was NOT the main interface, nothing happens.
        - If it was the main interface:
            - The first remaining snmpv3 interface for the host is selected.
            - That interface is promoted to `MainChoices.YES`.
            - A log entry is created documenting the promotion.
    
    """
    
    if instance.main == MainChoices.YES:
        logger.info( "running dev_promote_agent_interface_to_main" )
        remaining = instance.host.snmpv3_interfaces.exclude( pk=instance.pk )
        fallback = remaining.first()
        if fallback:
            fallback.main = MainChoices.YES
            fallback.save()
            logger.info( f"Promoted interface {fallback.name} to main interface for {fallback.host.get_name()}" )

#
# Save Zabbix configuration
#
@receiver(post_save, sender=DeviceZabbixConfig)
def dev_save_zabbix_config(sender, instance, created, **kwargs):
    """
    Update the corresponding host in Zabbix for a device when the Zabbix 
    configuration in NetBox has changed.
    """

    # Don't update upon creation
    if created:
        return

    logger.info( "running dev_save_zabbix_config" )

    # Get the request so we can access the request id
    request_id = None
    request = current_request.get()
    if request:
        request_id = request.id

    change = ObjectChange.objects.filter( changed_object_id=instance.pk ).order_by( '-time' ).first()
    if change and change.user:
        DeviceUpdateZabbixHost.run_job( device_name=instance.device.name, device_zabbix_config=instance, user=change.user, request_id=request_id )


#
# Delete Zabbix configuration
#
@receiver(pre_delete, sender=DeviceZabbixConfig)
def dev_delete_zabbix_config(sender, instance, **kwargs):
    """
    Delete the corresponding Zabbix host before removing a device configuration.
    
    This signal handler is triggered before a `DeviceZabbixConfig` instance 
    is deleted. It ensures that the associated host in Zabbix is also 
    deleted to maintain consistency between NetBox and Zabbix.
    
    Behavior:
        - Logs the deletion attempt, including the device name.
        - Calls the background job `DeleteZabbixHost.run_job()` with the 
          host ID from the configuration.
        - If the deletion in Zabbix fails, the exception is raised to 
          prevent inconsistent state.

    Note: The run_job is responsible for logging the current Zabbix host 
          configuration before deleteing the host in Zabbix.
    """

    logger.info( "running dev_delete_zabbix_config" )
    try:
        DeleteZabbixHost.run_job( hostid=instance.hostid )
    except Exception as e:
        raise e


# ------------------------------------------------------------------------------
# Interface
#

# Update
@receiver(post_save, sender=DeviceAgentInterface)
@receiver(post_save, sender=DeviceSNMPv3Interface)
def dev_save_zabbix_interface(sender, instance, created, **kwargs):
    """
    """
    # Don't update upon creation
    if created:
        return

    logger.info( "running dev_save_zabbix_interface" )
    
    # Get the request so we can access the request id
    request_id = None
    request = current_request.get()
    if request:
        request_id = request.id
        
    change = ObjectChange.objects.filter( changed_object_id=instance.pk ).order_by( '-time' ).first()
    if change and change.user:
        DeviceUpdateZabbixHost.run_job( device_name=instance.host.device.name, device_zabbix_config=instance.host, user=change.user, request_id=request_id )



# ------------------------------------------------------------------------------
# IP Address
#

# Update 
@receiver(post_save, sender=IPAddress)
def dev_update_ipaddress(sender, instance, created, **kwargs):
    """
    Update Zabbix host when an IPAddress changes.
    """

    # Don't update upon creation
    if created:
        return

    logger.info( "running dev_save_zabbix_interface" )

    # Find the most recent change (if any)
    change = ObjectChange.objects.filter( changed_object_id=instance.pk ).order_by( '-time' ).first()

    if not change or not change.user:
        return

    # If no assigned object (e.g., IP not bound to an interface/device), skip
    if not instance.assigned_object_id:
        return

    try:
        device = Device.objects.get(id=instance.assigned_object_id)
    except Device.DoesNotExist:
        # Assigned object ID refers to a missing device
        return

    try:
        device_zabbix_config = DeviceZabbixConfig.objects.get( device=device )
    except DeviceZabbixConfig.DoesNotExist:
        # Device has no Zabbix config â€” skip gracefully
        return
    except DeviceZabbixConfig.MultipleObjectsReturned:
        # Handle unexpected duplicates
        return


    # Get the request so we can access the request id
    request = current_request.get()
    
    # Run the update job
    DeviceUpdateZabbixHost.run_job( device_name=device.name, device_zabbix_config=device_zabbix_config, user=change.user, request_id=request.id )

# Delete
#from core.choices import ObjectChangeActionChoices
# from netbox.context import current_request
#@receiver(pre_delete, sender=DeviceAgentInterface)
#@receiver(pre_delete, sender=DeviceSNMPv3Interface)
#def dev_delete_zabbix_interface(sender, instance, **kwargs):
#    """
#        An interface in Zabbix cannot be removed if the host has items
#        that are configure to use the interface.
#        So we attempt to delete the interface in Zabbix and if that fails then
#        the delete in NetBox should fail.
#    """
#    request = current_request.get()
#    user = getattr(request, "user", None) if request else None
#    zconf = instance.host
#    interface = instance
#
#    logger.info( "*******************************" )
#    logger.info( "* dev_delete_zabbix_interface *" )
#    logger.info( "*******************************" )
#
#    if not can_remove_interface( zconf.hostid, interface.interfaceid ):
#        logger.error(f"Zabbix refused interface deletion for {interface}")
#        raise ValidationError( f"Cannot delete interface {interface.name} from host {zconf.device.name}: Zabbix refused." )
#        
#    DeviceUpdateZabbixHost.run_job( device_name=zconf.device.name, device_zabbix_config=zconf, user=user )
#
#    # Optionally log the object change in NetBox
#    if request and user:
#        update_obj_change(zconf, user, request.id)


# ------------------------------------------------------------------------------
# Virtual Machine Singals
# ------------------------------------------------------------------------------
